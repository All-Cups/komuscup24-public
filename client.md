# Создание стратегии

В пакете для вашего языка программирования вы можете найти файл `MyStrategy.<ext>`/`my_strategy.<ext>`.
Этот файл содержит класс `MyStrategy`, описывающий логику вашей стратегии.
Остальные файлы содержат логику подключения к серверу, описание игровых объектов и их де/сериализации.
Большинство из этих файлов автоматически сгенерированы, и желательно не менять их.

В начале игры сервер присылает константы, и создается экземпляр класса `MyStrategy` (вызывается конструктор).
Затем, каждый тик вызывается метод `get_order`, принимающий текущее динамическое состояние игры,
из которого вы должны вернуть приказы для своего игрока, которые вы желаете выполнить в этот тик.

При запуске клиента можно указать в аргументах командной строки хост и порт для подключения,
к примеру `python main.py localhost 31001`.
Если аргументы не указаны, подключение идет к `localhost:31001`.

## Отладочный интерфейс

Метод `get_order` также принимает отладочный интерфейс (`debug_interface`) - специальный объект,
с помощью которого вы можете отправлять отладочные команды и запрашивать отладочное состояние приложения прямо из кода вашей стратегии.
Заметьте, что этот объект недоступен при тестировании на сервере, а также использовании приложения в консольном режиме (`--batch-mode`).
Он предназначен только для локальной отладки.
Данные, отправленные через отладочный интерфейс из метода `get_order` сохранятся для того тика, для которого получались приказы.
Таким образом при перемотке вы сможете увидеть отладочные данные прошлых тиков.

Для отладки существует еще один метод — `debug_update`.
Он вызывается постоянно во время работы приложения (но не в консольном режиме), если клиент находится в ожидании следующего тика.
Данные, отправленные через отладочный интерфейс из `debug_update` сохраняются глобально,
то есть будут отображаться всегда, независимо от того, на какое место перемотан плеер.

## Описание объектов

Вы можете увидеть описание игровых сущностей как в коде клиента, так и в документации.
Некоторые поля могут быть опциональными (обозначается как `Option<type>`).
Способ реализации зависит от языка.
При возможности используется специальный опциональный (nullable) тип,
иначе другие методы могут быть использованы (например nullable указатели).

Некоторые объекты могут принимать несколько различных форм. Способ реализации зависит от языка.
Если возможно, используется специальный (алгебраический) тип данных,
иначе другие методы могут быть использованы (например варианты представлены классами, унаследованными от абстрактного базового класса).
